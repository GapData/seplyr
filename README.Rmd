---
output:
  md_document:
    variant: markdown_github
---

<!-- README.md is generated from README.Rmd. Please edit that file -->



```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = " # "
)
options(width =100)
```


This document describes the [`R`](https://www.r-project.org) package [`seplyr`](https://github.com/WinVector/seplyr) which supplies *s*tandard *e*valuation interfaces for some common [`dplyr`](https://CRAN.R-project.org/package=dplyr) verbs.

The idea is this package lets you program over `dplyr` 0.7.* without needing a Ph.D. in computer science.

To install this packing in `R` please either install from [CRAN](https://CRAN.R-project.org/package=seplyr) with:

```{r, eval=FALSE}
   install.packages('seplyr')
```

or from [GitHub](https://github.com/WinVector/seplyr):
 
```{r, eval=FALSE}
   devtools::install_github('WinVector/seplyr')
```
 

In `dplyr` if you know the names of columns when you are writing code you can write code such as the following.

```{r ex1a}
suppressPackageStartupMessages(library("dplyr"))
packageVersion("dplyr")

datasets::mtcars %>% 
  group_by(cyl, gear) %>% 
  head()
```

If instead the names of the columns are coming from a variable set elsewhere you need to use a tool to substitute those names in as show below.

```{r ex1b}
groupingVars <- c('cyl', 'gear') # assume this is set elsewhere

datasets::mtcars %>% 
  group_by(!!!rlang::syms(groupingVars)) %>% 
  head()
```

If you don't want to try and digest entire theory of quasi-quoting (the `rlang::syms()`) and splicing (the `!!!`) then you can use `seplyr` which conveniently wraps the operations as follows:

```{r ex1c}
# devtools::install_github('WinVector/seplyr')
library("seplyr")

datasets::mtcars %>% 
  group_by_se(groupingVars) %>% 
  head()
```

And that is it.  `seplyr::group_by_se()` performs the wrapping for you without you having to work through the details of `rlang`.  If you are interested in the details `seplyr` itself is a good tutorial.  For example you can examine `seplyr`'s implementation to see the necessary notations:

```{r pex1d}
print(group_by_se)
```

And of course we try to supply some usable help entries, such as: `help(group_by_se)`.

In addition to the series of adapters we also supply a number of useful new verbs including:

 * `group_summarize()` Binds grouping, arrangement, and summarization together for clear documentation of intent.
 * `add_group_summaries()` Adds per-group summaries to data.
 * `add_group_indices()` Adds a column of per-group ids to data.
 * `add_in_group_indices()` Adds a column of in-group rank ids to data.
 * `add_rank_indices()` Adds rank indices to data.

`seplyr` is designed to be a thin package that passes all work to `dplyr`.  If you want a package that works around `dplyr` implementation differences on different data sources I suggest trying our own [`replyr`]( https://CRAN.R-project.org/package=replyr) package.

**********

One (*very* advanced) caveat is given below. If you are working with normal in-memory data the following should not matter.

The caveat is: `seplyr` is an `R` package that declares a dependency on `dplyr`.

I *think* this means that `seplyr` is always calling the `dplyr` version of any non-`S3` verbs even if another package (such as `sparklyr` or `dbplyr`) has attempted to override them.  I believe run-time `S3` dispatch will correctly re-dispatch to class labeled derived methods.  If all relevant package have correct override hygiene there should not be any problems.

If you have any problems working with helper packages (such as `dbplyr` or `sparklyr`) you can try apply `base::source()` to all of the `*.R` files in [`seplyr/R`](https://github.com/WinVector/seplyr/tree/master/R) instead of loading the package.
